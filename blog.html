<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blog</title>
    <style>
        body {
            background-color: rgba(0, 0, 0, 0.135)
        }

        main {
            margin: 50px;
        }
    </style>
</head>

<body>
    <main>
        <!-- question 1 -->
        <h3>
            1. Local vs session storage
        </h3>
        <p>
            The main difference between localStorage and sessionStorage is that sessionStorage is unique per tab. If you
            close the tab the sessionStorage gets deleted, localStorage does not. Also you cannot communicate between
            tabs
            :)

            Another subtle difference is that for example on Safari (8.0.3) localStorage has a limit of 2551 k
            characters
            but sessionStorage has unlimited storage

            On Chrome (v43) both localStorage and sessionStorage are limited to 5101 k characters (no difference between
            normal / incognito mode)

            On Firefox both localStorage and sessionStorage are limited to 5120 k characters (no difference between
            normal /
            private mode )
        </p>
        <!-- question 2 -->
        <br>
        <br>
        <h3>
            2. Global scope vs block scope
        </h3>
        <p>
            We often identify those scopes as local scopes and identify the top-level scope as the global scope. In a
            browser environment, the global scope is controlled by the window object while in Node.js, it’s controlled
            by the global object.

            It’s hard to completely avoid the global scope, unless you’re coding purely functional style, but you should
            minimize the use of any global variables because they represent a state and having that defined globally
            makes it more vulnerable to conflicts and data corruption.
            Block scopes are what you get when you use if statements, for statements, and the like. You can also use
            them stand-alone with a simple begin-end curly braces {}, not to be confused with empty object literals.


        </p>

        <!-- question 3 -->
        <br>
        <br>
        <h3>
            3. What is the event loop in javaScript?
        </h3>
        <p>JavaScript has a runtime model based on an event loop, which is responsible for executing the code,
            collecting and processing events, and executing queued sub-tasks. This model is quite different from models
            in other languages like C and Java.A JavaScript runtime uses a message queue, which is a list of messages to
            be processed. Each message has an associated function that gets called to handle the message.

            At some point during the event loop, the runtime starts handling the messages on the queue, starting with
            the oldest one. To do so, the message is removed from the queue and its corresponding function is called
            with the message as an input parameter. As always, calling a function creates a new stack frame for that
            function's use.

            The processing of functions continues until the stack is once again empty. Then, the event loop will process
            the next message in the queue (if there is one).</p>
        <!-- question 4 -->
        <br>
        <br>
        <h3>
            4. Describe how many ways we get undefined
        </h3>
        <p></p>
    </main>
</body>

</html>